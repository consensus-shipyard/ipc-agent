// Copyright 2019-2022 ChainSafe Systems
// SPDX-License-Identifier: Apache-2.0, MIT
use std::{
    cmp,
    collections::VecDeque,
    task::{Context, Poll},
    time::Duration,
};

use libp2p::{
    core::connection::ConnectionId,
    kad::{handler::KademliaHandlerProto, store::MemoryStore, Kademlia, QueryId},
    swarm::{
        behaviour::toggle::{Toggle, ToggleIntoConnectionHandler},
        derive_prelude::FromSwarm,
        ConnectionHandler, IntoConnectionHandler, NetworkBehaviour, NetworkBehaviourAction,
        PollParameters,
    },
    Multiaddr, PeerId,
};
use tokio::time::Interval;

// NOTE: The Discovery behaviour is largely based on what exists in Forest. If it ain't broken...
// NOTE: Not sure if emitting events is going to be useful yet, but for now it's an example of having one.

/// Event generated by the `Discovery` behaviour.
#[derive(Debug)]
pub enum DiscoveryEvent {
    /// Event emitted when we first connect to a peer.
    Connected(PeerId, Vec<Multiaddr>),

    /// Event emitted when the last connection to a peer is closed.
    Disconnected(PeerId, Vec<Multiaddr>),
}

/// Discovery behaviour, periodically running a random lookup with Kademlia to find new peers.
///
/// Our other option for peer discovery would be to rely on the Peer Exchange of Gossipsub.
/// However, the required Signed Records feature is not available in the Rust version of the library, as of v0.50.
pub struct Discovery {
    /// User-defined list of nodes and their addresses.
    /// Typically includes bootstrap nodes, or it can be used for a static network.
    user_defined: Vec<(PeerId, Multiaddr)>,
    /// Kademlia behaviour, if enabled.
    inner: Toggle<Kademlia<MemoryStore>>,
    /// Number of current connections.
    num_connections: usize,
    /// Number of connections where further lookups are paused.
    max_connections: usize,
    /// Interval between random lookups.
    lookup_interval: Interval,
    /// Events to return when polled.
    outbox: VecDeque<DiscoveryEvent>,
}

impl NetworkBehaviour for Discovery {
    type ConnectionHandler = ToggleIntoConnectionHandler<KademliaHandlerProto<QueryId>>;

    type OutEvent = DiscoveryEvent;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        self.inner.new_handler()
    }

    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        let mut addrs = self
            .user_defined
            .iter()
            .filter(|(p, _)| p == peer_id)
            .map(|(_, a)| a.clone())
            .collect::<Vec<_>>();

        addrs.extend(self.inner.addresses_of_peer(peer_id));
        addrs
    }

    fn on_swarm_event(&mut self, event: FromSwarm<Self::ConnectionHandler>) {
        match &event {
            FromSwarm::ConnectionEstablished(e) => {
                self.num_connections += 1;
                if e.other_established == 0 {
                    let addrs = self.addresses_of_peer(&e.peer_id);
                    self.outbox
                        .push_back(DiscoveryEvent::Connected(e.peer_id, addrs));
                }
            }
            FromSwarm::ConnectionClosed(e) => {
                self.num_connections -= 1;
                if e.remaining_established == 0 {
                    let addrs = self.addresses_of_peer(&e.peer_id);
                    self.outbox
                        .push_back(DiscoveryEvent::Disconnected(e.peer_id, addrs));
                }
            }
            _ => {}
        };
        self.inner.on_swarm_event(event)
    }

    fn on_connection_handler_event(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
    ) {
        self.inner
            .on_connection_handler_event(peer_id, connection_id, event)
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> std::task::Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        // Emit own events first.
        if let Some(ev) = self.outbox.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(ev));
        }

        // Trigger periodic queries.
        if self.lookup_interval.poll_tick(cx).is_ready() {
            if self.num_connections < self.max_connections {
                let random_peer_id = PeerId::random();
                if let Some(k) = self.inner.as_mut() {
                    k.get_closest_peers(random_peer_id);
                }
            }

            // Schedule the next random query with exponentially increasing delay, capped at 60 seconds.
            self.lookup_interval = tokio::time::interval(cmp::min(
                self.lookup_interval.period() * 2,
                Duration::from_secs(60),
            ));
            // we need to reset the interval, otherwise the next tick completes immediately.
            self.lookup_interval.reset();
        }

        // Poll Kademlia.
        while let Poll::Ready(ev) = self.inner.poll(cx, params) {
            match ev {
                // Not propagating Kademlia specific events, just the ones meant for the Swarm.
                NetworkBehaviourAction::GenerateEvent(_out) => {
                    continue;
                }
                other => {
                    return Poll::Ready(other.map_out(|_| unreachable!("continue'd")));
                }
            }
        }

        Poll::Pending
    }
}
